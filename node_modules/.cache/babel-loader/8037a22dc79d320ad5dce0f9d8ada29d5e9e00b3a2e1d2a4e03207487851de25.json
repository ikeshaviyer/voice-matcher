{"ast":null,"code":"class AudioManager {\n  constructor() {\n    this.audioContext = null;\n    this.audioBuffers = new Map();\n    this.currentSource = null;\n    this.initAudioContext();\n  }\n  initAudioContext() {\n    try {\n      this.audioContext = new AudioContext();\n    } catch (error) {\n      console.error('Failed to create AudioContext:', error);\n    }\n  }\n  async loadAudioClip(clip) {\n    if (!this.audioContext) return;\n    try {\n      const response = await fetch(clip.file);\n      const arrayBuffer = await response.arrayBuffer();\n      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\n      this.audioBuffers.set(clip.id, audioBuffer);\n    } catch (error) {\n      console.error(`Failed to load audio clip ${clip.name}:`, error);\n    }\n  }\n  async loadAllClips(clips) {\n    await Promise.all(clips.map(clip => this.loadAudioClip(clip)));\n  }\n  play(clipId) {\n    return new Promise((resolve, reject) => {\n      if (!this.audioContext) {\n        reject(new Error('AudioContext not initialized'));\n        return;\n      }\n      const buffer = this.audioBuffers.get(clipId);\n      if (!buffer) {\n        reject(new Error(`Audio clip ${clipId} not loaded`));\n        return;\n      }\n\n      // Stop any currently playing audio\n      if (this.currentSource) {\n        this.currentSource.stop();\n      }\n\n      // Create and configure new source\n      this.currentSource = this.audioContext.createBufferSource();\n      this.currentSource.buffer = buffer;\n      this.currentSource.connect(this.audioContext.destination);\n\n      // Handle completion\n      this.currentSource.onended = () => {\n        this.currentSource = null;\n        resolve();\n      };\n\n      // Start playback\n      this.currentSource.start();\n    });\n  }\n  stop() {\n    if (this.currentSource) {\n      this.currentSource.stop();\n      this.currentSource = null;\n    }\n  }\n}\n\n// Create a singleton instance\nexport const audioManager = new AudioManager();","map":{"version":3,"names":["AudioManager","constructor","audioContext","audioBuffers","Map","currentSource","initAudioContext","AudioContext","error","console","loadAudioClip","clip","response","fetch","file","arrayBuffer","audioBuffer","decodeAudioData","set","id","name","loadAllClips","clips","Promise","all","map","play","clipId","resolve","reject","Error","buffer","get","stop","createBufferSource","connect","destination","onended","start","audioManager"],"sources":["C:/Users/ikesh/Desktop/voice-matcher/src/utils/audioUtils.ts"],"sourcesContent":["import { AudioClip } from '../types/audio';\r\n\r\nclass AudioManager {\r\n  private audioContext: AudioContext | null = null;\r\n  private audioBuffers: Map<string, AudioBuffer> = new Map();\r\n  private currentSource: AudioBufferSourceNode | null = null;\r\n\r\n  constructor() {\r\n    this.initAudioContext();\r\n  }\r\n\r\n  private initAudioContext() {\r\n    try {\r\n      this.audioContext = new AudioContext();\r\n    } catch (error) {\r\n      console.error('Failed to create AudioContext:', error);\r\n    }\r\n  }\r\n\r\n  async loadAudioClip(clip: AudioClip): Promise<void> {\r\n    if (!this.audioContext) return;\r\n\r\n    try {\r\n      const response = await fetch(clip.file);\r\n      const arrayBuffer = await response.arrayBuffer();\r\n      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\r\n      this.audioBuffers.set(clip.id, audioBuffer);\r\n    } catch (error) {\r\n      console.error(`Failed to load audio clip ${clip.name}:`, error);\r\n    }\r\n  }\r\n\r\n  async loadAllClips(clips: AudioClip[]): Promise<void> {\r\n    await Promise.all(clips.map(clip => this.loadAudioClip(clip)));\r\n  }\r\n\r\n  play(clipId: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.audioContext) {\r\n        reject(new Error('AudioContext not initialized'));\r\n        return;\r\n      }\r\n\r\n      const buffer = this.audioBuffers.get(clipId);\r\n      if (!buffer) {\r\n        reject(new Error(`Audio clip ${clipId} not loaded`));\r\n        return;\r\n      }\r\n\r\n      // Stop any currently playing audio\r\n      if (this.currentSource) {\r\n        this.currentSource.stop();\r\n      }\r\n\r\n      // Create and configure new source\r\n      this.currentSource = this.audioContext.createBufferSource();\r\n      this.currentSource.buffer = buffer;\r\n      this.currentSource.connect(this.audioContext.destination);\r\n\r\n      // Handle completion\r\n      this.currentSource.onended = () => {\r\n        this.currentSource = null;\r\n        resolve();\r\n      };\r\n\r\n      // Start playback\r\n      this.currentSource.start();\r\n    });\r\n  }\r\n\r\n  stop() {\r\n    if (this.currentSource) {\r\n      this.currentSource.stop();\r\n      this.currentSource = null;\r\n    }\r\n  }\r\n}\r\n\r\n// Create a singleton instance\r\nexport const audioManager = new AudioManager(); "],"mappings":"AAEA,MAAMA,YAAY,CAAC;EAKjBC,WAAWA,CAAA,EAAG;IAAA,KAJNC,YAAY,GAAwB,IAAI;IAAA,KACxCC,YAAY,GAA6B,IAAIC,GAAG,CAAC,CAAC;IAAA,KAClDC,aAAa,GAAiC,IAAI;IAGxD,IAAI,CAACC,gBAAgB,CAAC,CAAC;EACzB;EAEQA,gBAAgBA,CAAA,EAAG;IACzB,IAAI;MACF,IAAI,CAACJ,YAAY,GAAG,IAAIK,YAAY,CAAC,CAAC;IACxC,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACxD;EACF;EAEA,MAAME,aAAaA,CAACC,IAAe,EAAiB;IAClD,IAAI,CAAC,IAAI,CAACT,YAAY,EAAE;IAExB,IAAI;MACF,MAAMU,QAAQ,GAAG,MAAMC,KAAK,CAACF,IAAI,CAACG,IAAI,CAAC;MACvC,MAAMC,WAAW,GAAG,MAAMH,QAAQ,CAACG,WAAW,CAAC,CAAC;MAChD,MAAMC,WAAW,GAAG,MAAM,IAAI,CAACd,YAAY,CAACe,eAAe,CAACF,WAAW,CAAC;MACxE,IAAI,CAACZ,YAAY,CAACe,GAAG,CAACP,IAAI,CAACQ,EAAE,EAAEH,WAAW,CAAC;IAC7C,CAAC,CAAC,OAAOR,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,6BAA6BG,IAAI,CAACS,IAAI,GAAG,EAAEZ,KAAK,CAAC;IACjE;EACF;EAEA,MAAMa,YAAYA,CAACC,KAAkB,EAAiB;IACpD,MAAMC,OAAO,CAACC,GAAG,CAACF,KAAK,CAACG,GAAG,CAACd,IAAI,IAAI,IAAI,CAACD,aAAa,CAACC,IAAI,CAAC,CAAC,CAAC;EAChE;EAEAe,IAAIA,CAACC,MAAc,EAAiB;IAClC,OAAO,IAAIJ,OAAO,CAAC,CAACK,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI,CAAC,IAAI,CAAC3B,YAAY,EAAE;QACtB2B,MAAM,CAAC,IAAIC,KAAK,CAAC,8BAA8B,CAAC,CAAC;QACjD;MACF;MAEA,MAAMC,MAAM,GAAG,IAAI,CAAC5B,YAAY,CAAC6B,GAAG,CAACL,MAAM,CAAC;MAC5C,IAAI,CAACI,MAAM,EAAE;QACXF,MAAM,CAAC,IAAIC,KAAK,CAAC,cAAcH,MAAM,aAAa,CAAC,CAAC;QACpD;MACF;;MAEA;MACA,IAAI,IAAI,CAACtB,aAAa,EAAE;QACtB,IAAI,CAACA,aAAa,CAAC4B,IAAI,CAAC,CAAC;MAC3B;;MAEA;MACA,IAAI,CAAC5B,aAAa,GAAG,IAAI,CAACH,YAAY,CAACgC,kBAAkB,CAAC,CAAC;MAC3D,IAAI,CAAC7B,aAAa,CAAC0B,MAAM,GAAGA,MAAM;MAClC,IAAI,CAAC1B,aAAa,CAAC8B,OAAO,CAAC,IAAI,CAACjC,YAAY,CAACkC,WAAW,CAAC;;MAEzD;MACA,IAAI,CAAC/B,aAAa,CAACgC,OAAO,GAAG,MAAM;QACjC,IAAI,CAAChC,aAAa,GAAG,IAAI;QACzBuB,OAAO,CAAC,CAAC;MACX,CAAC;;MAED;MACA,IAAI,CAACvB,aAAa,CAACiC,KAAK,CAAC,CAAC;IAC5B,CAAC,CAAC;EACJ;EAEAL,IAAIA,CAAA,EAAG;IACL,IAAI,IAAI,CAAC5B,aAAa,EAAE;MACtB,IAAI,CAACA,aAAa,CAAC4B,IAAI,CAAC,CAAC;MACzB,IAAI,CAAC5B,aAAa,GAAG,IAAI;IAC3B;EACF;AACF;;AAEA;AACA,OAAO,MAAMkC,YAAY,GAAG,IAAIvC,YAAY,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}