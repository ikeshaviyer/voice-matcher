{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef } from 'react';\nexport const useVoiceRecorder = deviceId => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [error, setError] = useState(null);\n  const mediaRecorder = useRef(null);\n  const chunks = useRef([]);\n  const startRecording = async () => {\n    try {\n      chunks.current = [];\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          deviceId: {\n            exact: deviceId\n          },\n          echoCancellation: false,\n          noiseSuppression: false,\n          autoGainControl: false\n        }\n      });\n      mediaRecorder.current = new MediaRecorder(stream);\n      mediaRecorder.current.ondataavailable = e => {\n        if (e.data.size > 0) {\n          chunks.current.push(e.data);\n        }\n      };\n\n      // Request data every 100ms to ensure we get the full recording\n      mediaRecorder.current.start(100);\n      setIsRecording(true);\n      setError(null);\n    } catch (err) {\n      setError('Failed to start recording');\n      console.error('Recording error:', err);\n    }\n  };\n  const stopRecording = async () => {\n    return new Promise((resolve, reject) => {\n      if (!mediaRecorder.current) {\n        reject(new Error('No active recording'));\n        return;\n      }\n\n      // Add ondataavailable handler for final chunk\n      mediaRecorder.current.ondataavailable = e => {\n        if (e.data.size > 0) {\n          chunks.current.push(e.data);\n        }\n      };\n\n      // Add onstop handler\n      mediaRecorder.current.onstop = () => {\n        var _mediaRecorder$curren;\n        const blob = new Blob(chunks.current, {\n          type: 'audio/webm'\n        });\n        chunks.current = [];\n        setIsRecording(false);\n\n        // Stop all tracks\n        (_mediaRecorder$curren = mediaRecorder.current) === null || _mediaRecorder$curren === void 0 ? void 0 : _mediaRecorder$curren.stream.getTracks().forEach(track => track.stop());\n        resolve(blob);\n      };\n\n      // Only stop if we're actually recording\n      if (mediaRecorder.current.state === 'recording') {\n        mediaRecorder.current.stop();\n      } else {\n        reject(new Error('No active recording'));\n      }\n    });\n  };\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    error\n  };\n};\n_s(useVoiceRecorder, \"AanfGgg5EGTXt6PlUCLcA2JwxmY=\");","map":{"version":3,"names":["useState","useRef","useVoiceRecorder","deviceId","_s","isRecording","setIsRecording","error","setError","mediaRecorder","chunks","startRecording","current","stream","navigator","mediaDevices","getUserMedia","audio","exact","echoCancellation","noiseSuppression","autoGainControl","MediaRecorder","ondataavailable","e","data","size","push","start","err","console","stopRecording","Promise","resolve","reject","Error","onstop","_mediaRecorder$curren","blob","Blob","type","getTracks","forEach","track","stop","state"],"sources":["C:/Users/ikesh/Desktop/voice-matcher/src/hooks/useVoiceRecorder.ts"],"sourcesContent":["import { useState, useRef } from 'react';\r\n\r\ninterface VoiceRecorderHook {\r\n  startRecording: () => Promise<void>;\r\n  stopRecording: () => Promise<Blob>;\r\n  isRecording: boolean;\r\n  error: string | null;\r\n}\r\n\r\nexport const useVoiceRecorder = (deviceId: string): VoiceRecorderHook => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const mediaRecorder = useRef<MediaRecorder | null>(null);\r\n  const chunks = useRef<Blob[]>([]);\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      chunks.current = [];\r\n      const stream = await navigator.mediaDevices.getUserMedia({\r\n        audio: {\r\n          deviceId: { exact: deviceId },\r\n          echoCancellation: false,\r\n          noiseSuppression: false,\r\n          autoGainControl: false\r\n        }\r\n      });\r\n\r\n      mediaRecorder.current = new MediaRecorder(stream);\r\n\r\n      mediaRecorder.current.ondataavailable = (e) => {\r\n        if (e.data.size > 0) {\r\n          chunks.current.push(e.data);\r\n        }\r\n      };\r\n\r\n      // Request data every 100ms to ensure we get the full recording\r\n      mediaRecorder.current.start(100);\r\n      setIsRecording(true);\r\n      setError(null);\r\n    } catch (err) {\r\n      setError('Failed to start recording');\r\n      console.error('Recording error:', err);\r\n    }\r\n  };\r\n\r\n  const stopRecording = async (): Promise<Blob> => {\r\n    return new Promise((resolve, reject) => {\r\n      if (!mediaRecorder.current) {\r\n        reject(new Error('No active recording'));\r\n        return;\r\n      }\r\n\r\n      // Add ondataavailable handler for final chunk\r\n      mediaRecorder.current.ondataavailable = (e) => {\r\n        if (e.data.size > 0) {\r\n          chunks.current.push(e.data);\r\n        }\r\n      };\r\n\r\n      // Add onstop handler\r\n      mediaRecorder.current.onstop = () => {\r\n        const blob = new Blob(chunks.current, { type: 'audio/webm' });\r\n        chunks.current = [];\r\n        setIsRecording(false);\r\n\r\n        // Stop all tracks\r\n        mediaRecorder.current?.stream.getTracks().forEach(track => track.stop());\r\n        \r\n        resolve(blob);\r\n      };\r\n\r\n      // Only stop if we're actually recording\r\n      if (mediaRecorder.current.state === 'recording') {\r\n        mediaRecorder.current.stop();\r\n      } else {\r\n        reject(new Error('No active recording'));\r\n      }\r\n    });\r\n  };\r\n\r\n  return {\r\n    startRecording,\r\n    stopRecording,\r\n    isRecording,\r\n    error\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}