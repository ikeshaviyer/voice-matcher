{"ast":null,"code":"class AudioManager {\n  // Will be initialized in constructor\n\n  constructor() {\n    this.audioBuffers = new Map();\n    this.currentSource = null;\n    this.context = void 0;\n    this.context = new AudioContext();\n  }\n  async initAudioContext() {\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n  }\n  async loadAudioClips(clips) {\n    await this.initAudioContext();\n    await Promise.all(clips.map(clip => this.loadSingleClip(clip)));\n  }\n  async loadSingleClip(clip) {\n    try {\n      const response = await fetch(clip.file);\n      const arrayBuffer = await response.arrayBuffer();\n      const audioBuffer = await this.context.decodeAudioData(arrayBuffer);\n\n      // Set the actual duration in milliseconds\n      clip.duration = audioBuffer.duration * 1000;\n      this.audioBuffers.set(clip.id, audioBuffer);\n    } catch (error) {\n      console.error(`Failed to load audio clip ${clip.name}:`, error);\n    }\n  }\n  async loadAllClips(clips) {\n    await this.initAudioContext();\n    await Promise.all(clips.map(clip => this.loadSingleClip(clip)));\n  }\n  play(clipId) {\n    return new Promise((resolve, reject) => {\n      if (!this.context) {\n        reject(new Error('AudioContext not initialized'));\n        return;\n      }\n      const buffer = this.audioBuffers.get(clipId);\n      if (!buffer) {\n        reject(new Error(`Audio clip ${clipId} not loaded`));\n        return;\n      }\n\n      // Stop any currently playing audio\n      if (this.currentSource) {\n        this.currentSource.stop();\n      }\n\n      // Create and configure new source\n      this.currentSource = this.context.createBufferSource();\n      this.currentSource.buffer = buffer;\n      this.currentSource.connect(this.context.destination);\n\n      // Handle completion\n      this.currentSource.onended = () => {\n        this.currentSource = null;\n        resolve();\n      };\n\n      // Start playback\n      this.currentSource.start();\n    });\n  }\n  stop() {\n    if (this.currentSource) {\n      this.currentSource.stop();\n      this.currentSource = null;\n    }\n  }\n  getBuffer(clipId) {\n    return this.audioBuffers.get(clipId);\n  }\n}\n\n// Create a singleton instance\nexport const audioManager = new AudioManager();","map":{"version":3,"names":["AudioManager","constructor","audioBuffers","Map","currentSource","context","AudioContext","initAudioContext","state","resume","loadAudioClips","clips","Promise","all","map","clip","loadSingleClip","response","fetch","file","arrayBuffer","audioBuffer","decodeAudioData","duration","set","id","error","console","name","loadAllClips","play","clipId","resolve","reject","Error","buffer","get","stop","createBufferSource","connect","destination","onended","start","getBuffer","audioManager"],"sources":["C:/Users/ikesh/Desktop/voice-matcher/src/utils/audioUtils.ts"],"sourcesContent":["import { AudioClip } from '../types/audio';\r\n\r\nclass AudioManager {\r\n  private audioBuffers: Map<string, AudioBuffer> = new Map();\r\n  private currentSource: AudioBufferSourceNode | null = null;\r\n  private context: AudioContext; // Will be initialized in constructor\r\n\r\n  constructor() {\r\n    this.context = new AudioContext();\r\n  }\r\n\r\n  private async initAudioContext() {\r\n    if (this.context.state === 'suspended') {\r\n      await this.context.resume();\r\n    }\r\n  }\r\n\r\n  async loadAudioClips(clips: AudioClip[]): Promise<void> {\r\n    await this.initAudioContext();\r\n    await Promise.all(clips.map(clip => this.loadSingleClip(clip)));\r\n  }\r\n\r\n  private async loadSingleClip(clip: AudioClip): Promise<void> {\r\n    try {\r\n      const response = await fetch(clip.file);\r\n      const arrayBuffer = await response.arrayBuffer();\r\n      const audioBuffer = await this.context.decodeAudioData(arrayBuffer);\r\n      \r\n      // Set the actual duration in milliseconds\r\n      clip.duration = audioBuffer.duration * 1000;\r\n      \r\n      this.audioBuffers.set(clip.id, audioBuffer);\r\n    } catch (error) {\r\n      console.error(`Failed to load audio clip ${clip.name}:`, error);\r\n    }\r\n  }\r\n\r\n  async loadAllClips(clips: AudioClip[]): Promise<void> {\r\n    await this.initAudioContext();\r\n    await Promise.all(clips.map(clip => this.loadSingleClip(clip)));\r\n  }\r\n\r\n  play(clipId: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.context) {\r\n        reject(new Error('AudioContext not initialized'));\r\n        return;\r\n      }\r\n\r\n      const buffer = this.audioBuffers.get(clipId);\r\n      if (!buffer) {\r\n        reject(new Error(`Audio clip ${clipId} not loaded`));\r\n        return;\r\n      }\r\n\r\n      // Stop any currently playing audio\r\n      if (this.currentSource) {\r\n        this.currentSource.stop();\r\n      }\r\n\r\n      // Create and configure new source\r\n      this.currentSource = this.context.createBufferSource();\r\n      this.currentSource.buffer = buffer;\r\n      this.currentSource.connect(this.context.destination);\r\n\r\n      // Handle completion\r\n      this.currentSource.onended = () => {\r\n        this.currentSource = null;\r\n        resolve();\r\n      };\r\n\r\n      // Start playback\r\n      this.currentSource.start();\r\n    });\r\n  }\r\n\r\n  stop() {\r\n    if (this.currentSource) {\r\n      this.currentSource.stop();\r\n      this.currentSource = null;\r\n    }\r\n  }\r\n\r\n  getBuffer(clipId: string): AudioBuffer | undefined {\r\n    return this.audioBuffers.get(clipId);\r\n  }\r\n}\r\n\r\n// Create a singleton instance\r\nexport const audioManager = new AudioManager(); "],"mappings":"AAEA,MAAMA,YAAY,CAAC;EAGc;;EAE/BC,WAAWA,CAAA,EAAG;IAAA,KAJNC,YAAY,GAA6B,IAAIC,GAAG,CAAC,CAAC;IAAA,KAClDC,aAAa,GAAiC,IAAI;IAAA,KAClDC,OAAO;IAGb,IAAI,CAACA,OAAO,GAAG,IAAIC,YAAY,CAAC,CAAC;EACnC;EAEA,MAAcC,gBAAgBA,CAAA,EAAG;IAC/B,IAAI,IAAI,CAACF,OAAO,CAACG,KAAK,KAAK,WAAW,EAAE;MACtC,MAAM,IAAI,CAACH,OAAO,CAACI,MAAM,CAAC,CAAC;IAC7B;EACF;EAEA,MAAMC,cAAcA,CAACC,KAAkB,EAAiB;IACtD,MAAM,IAAI,CAACJ,gBAAgB,CAAC,CAAC;IAC7B,MAAMK,OAAO,CAACC,GAAG,CAACF,KAAK,CAACG,GAAG,CAACC,IAAI,IAAI,IAAI,CAACC,cAAc,CAACD,IAAI,CAAC,CAAC,CAAC;EACjE;EAEA,MAAcC,cAAcA,CAACD,IAAe,EAAiB;IAC3D,IAAI;MACF,MAAME,QAAQ,GAAG,MAAMC,KAAK,CAACH,IAAI,CAACI,IAAI,CAAC;MACvC,MAAMC,WAAW,GAAG,MAAMH,QAAQ,CAACG,WAAW,CAAC,CAAC;MAChD,MAAMC,WAAW,GAAG,MAAM,IAAI,CAAChB,OAAO,CAACiB,eAAe,CAACF,WAAW,CAAC;;MAEnE;MACAL,IAAI,CAACQ,QAAQ,GAAGF,WAAW,CAACE,QAAQ,GAAG,IAAI;MAE3C,IAAI,CAACrB,YAAY,CAACsB,GAAG,CAACT,IAAI,CAACU,EAAE,EAAEJ,WAAW,CAAC;IAC7C,CAAC,CAAC,OAAOK,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,6BAA6BX,IAAI,CAACa,IAAI,GAAG,EAAEF,KAAK,CAAC;IACjE;EACF;EAEA,MAAMG,YAAYA,CAAClB,KAAkB,EAAiB;IACpD,MAAM,IAAI,CAACJ,gBAAgB,CAAC,CAAC;IAC7B,MAAMK,OAAO,CAACC,GAAG,CAACF,KAAK,CAACG,GAAG,CAACC,IAAI,IAAI,IAAI,CAACC,cAAc,CAACD,IAAI,CAAC,CAAC,CAAC;EACjE;EAEAe,IAAIA,CAACC,MAAc,EAAiB;IAClC,OAAO,IAAInB,OAAO,CAAC,CAACoB,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI,CAAC,IAAI,CAAC5B,OAAO,EAAE;QACjB4B,MAAM,CAAC,IAAIC,KAAK,CAAC,8BAA8B,CAAC,CAAC;QACjD;MACF;MAEA,MAAMC,MAAM,GAAG,IAAI,CAACjC,YAAY,CAACkC,GAAG,CAACL,MAAM,CAAC;MAC5C,IAAI,CAACI,MAAM,EAAE;QACXF,MAAM,CAAC,IAAIC,KAAK,CAAC,cAAcH,MAAM,aAAa,CAAC,CAAC;QACpD;MACF;;MAEA;MACA,IAAI,IAAI,CAAC3B,aAAa,EAAE;QACtB,IAAI,CAACA,aAAa,CAACiC,IAAI,CAAC,CAAC;MAC3B;;MAEA;MACA,IAAI,CAACjC,aAAa,GAAG,IAAI,CAACC,OAAO,CAACiC,kBAAkB,CAAC,CAAC;MACtD,IAAI,CAAClC,aAAa,CAAC+B,MAAM,GAAGA,MAAM;MAClC,IAAI,CAAC/B,aAAa,CAACmC,OAAO,CAAC,IAAI,CAAClC,OAAO,CAACmC,WAAW,CAAC;;MAEpD;MACA,IAAI,CAACpC,aAAa,CAACqC,OAAO,GAAG,MAAM;QACjC,IAAI,CAACrC,aAAa,GAAG,IAAI;QACzB4B,OAAO,CAAC,CAAC;MACX,CAAC;;MAED;MACA,IAAI,CAAC5B,aAAa,CAACsC,KAAK,CAAC,CAAC;IAC5B,CAAC,CAAC;EACJ;EAEAL,IAAIA,CAAA,EAAG;IACL,IAAI,IAAI,CAACjC,aAAa,EAAE;MACtB,IAAI,CAACA,aAAa,CAACiC,IAAI,CAAC,CAAC;MACzB,IAAI,CAACjC,aAAa,GAAG,IAAI;IAC3B;EACF;EAEAuC,SAASA,CAACZ,MAAc,EAA2B;IACjD,OAAO,IAAI,CAAC7B,YAAY,CAACkC,GAAG,CAACL,MAAM,CAAC;EACtC;AACF;;AAEA;AACA,OAAO,MAAMa,YAAY,GAAG,IAAI5C,YAAY,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}