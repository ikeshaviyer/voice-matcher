{"ast":null,"code":"export class AudioAnalyzer {\n  constructor() {\n    this.context = void 0;\n    this.context = new AudioContext();\n  }\n  async analyzePitch(audioBuffer) {\n    const analyzer = this.context.createAnalyser();\n    analyzer.fftSize = 2048;\n    const source = this.context.createBufferSource();\n    source.buffer = audioBuffer;\n    source.connect(analyzer);\n    analyzer.connect(this.context.destination);\n\n    // Start the source\n    source.start(0);\n\n    // Wait a small amount of time for the audio to start playing\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // Get frequency data\n    const pitchArray = new Float32Array(analyzer.frequencyBinCount);\n    analyzer.getFloatFrequencyData(pitchArray);\n\n    // Stop the source\n    source.stop();\n    source.disconnect();\n    analyzer.disconnect();\n\n    // Get amplitude data using our improved method\n    const rawData = new Float32Array(audioBuffer.length);\n    audioBuffer.copyFromChannel(rawData, 0);\n    const windowSize = 1024;\n    const amplitudeData = [];\n    for (let i = 0; i < rawData.length; i += windowSize) {\n      let sum = 0;\n      const end = Math.min(i + windowSize, rawData.length);\n      for (let j = i; j < end; j++) {\n        sum += rawData[j] * rawData[j];\n      }\n      const rms = Math.sqrt(sum / (end - i));\n      amplitudeData.push(rms);\n    }\n    return {\n      pitchData: Array.from(pitchArray),\n      amplitudeData,\n      duration: audioBuffer.duration\n    };\n  }\n  async compareAudio(original, recorded) {\n    // Check if recording is just silence\n    const recordedAvgAmplitude = this.getAverageAmplitude(recorded.amplitudeData);\n    if (recordedAvgAmplitude < 0.01) {\n      return {\n        score: 0,\n        durationMatch: 0,\n        pitchMatch: 0,\n        amplitudeMatch: 0\n      };\n    }\n\n    // Duration score (20%)\n    const durationMatch = Math.max(0, 100 - Math.abs(original.duration - recorded.duration) / original.duration * 100);\n\n    // Pitch score (40%)\n    const pitchMatch = this.compareArrays(original.pitchData, recorded.pitchData);\n\n    // Amplitude score (40%)\n    const amplitudeMatch = this.compareArrays(original.amplitudeData, recorded.amplitudeData);\n    const score = Math.round(durationMatch * 0.2 + pitchMatch * 0.4 + amplitudeMatch * 0.4);\n    return {\n      score,\n      durationMatch,\n      pitchMatch,\n      amplitudeMatch\n    };\n  }\n  getAverageAmplitude(arr) {\n    if (arr.length === 0) return 0;\n    const sum = arr.reduce((a, b) => a + Math.abs(b), 0);\n    return sum / arr.length;\n  }\n  compareArrays(arr1, arr2) {\n    const length = Math.min(arr1.length, arr2.length);\n    const normalizedArr1 = this.normalizeArray(arr1.slice(0, length));\n    const normalizedArr2 = this.normalizeArray(arr2.slice(0, length));\n    let totalDiff = 0;\n    let significantPoints = 0;\n    for (let i = 0; i < length; i++) {\n      // Only compare points where at least one signal has significant amplitude\n      if (normalizedArr1[i] > 0.1 || normalizedArr2[i] > 0.1) {\n        totalDiff += Math.abs(normalizedArr1[i] - normalizedArr2[i]);\n        significantPoints++;\n      }\n    }\n    if (significantPoints === 0) return 0;\n    return Math.max(0, 100 - totalDiff / significantPoints * 100);\n  }\n  normalizeArray(arr) {\n    const max = Math.max(...arr);\n    if (max === 0) return arr; // Prevent division by zero\n\n    return arr.map(value => value / max);\n  }\n  async audioBufferFromBlob(blob) {\n    const arrayBuffer = await blob.arrayBuffer();\n    return await this.context.decodeAudioData(arrayBuffer);\n  }\n}\nexport const audioAnalyzer = new AudioAnalyzer();","map":{"version":3,"names":["AudioAnalyzer","constructor","context","AudioContext","analyzePitch","audioBuffer","analyzer","createAnalyser","fftSize","source","createBufferSource","buffer","connect","destination","start","Promise","resolve","setTimeout","pitchArray","Float32Array","frequencyBinCount","getFloatFrequencyData","stop","disconnect","rawData","length","copyFromChannel","windowSize","amplitudeData","i","sum","end","Math","min","j","rms","sqrt","push","pitchData","Array","from","duration","compareAudio","original","recorded","recordedAvgAmplitude","getAverageAmplitude","score","durationMatch","pitchMatch","amplitudeMatch","max","abs","compareArrays","round","arr","reduce","a","b","arr1","arr2","normalizedArr1","normalizeArray","slice","normalizedArr2","totalDiff","significantPoints","map","value","audioBufferFromBlob","blob","arrayBuffer","decodeAudioData","audioAnalyzer"],"sources":["C:/Users/ikesh/Desktop/voice-matcher/src/utils/audioAnalysis.ts"],"sourcesContent":["export interface AudioFeatures {\r\n  pitchData: number[];\r\n  amplitudeData: number[];\r\n  duration: number;\r\n}\r\n\r\nexport class AudioAnalyzer {\r\n  private context: AudioContext;\r\n  \r\n  constructor() {\r\n    this.context = new AudioContext();\r\n  }\r\n\r\n  async analyzePitch(audioBuffer: AudioBuffer): Promise<AudioFeatures> {\r\n    const analyzer = this.context.createAnalyser();\r\n    analyzer.fftSize = 2048;\r\n    \r\n    const source = this.context.createBufferSource();\r\n    source.buffer = audioBuffer;\r\n    source.connect(analyzer);\r\n    analyzer.connect(this.context.destination);\r\n    \r\n    // Start the source\r\n    source.start(0);\r\n    \r\n    // Wait a small amount of time for the audio to start playing\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    \r\n    // Get frequency data\r\n    const pitchArray = new Float32Array(analyzer.frequencyBinCount);\r\n    analyzer.getFloatFrequencyData(pitchArray);\r\n    \r\n    // Stop the source\r\n    source.stop();\r\n    source.disconnect();\r\n    analyzer.disconnect();\r\n    \r\n    // Get amplitude data using our improved method\r\n    const rawData = new Float32Array(audioBuffer.length);\r\n    audioBuffer.copyFromChannel(rawData, 0);\r\n    \r\n    const windowSize = 1024;\r\n    const amplitudeData: number[] = [];\r\n    \r\n    for (let i = 0; i < rawData.length; i += windowSize) {\r\n      let sum = 0;\r\n      const end = Math.min(i + windowSize, rawData.length);\r\n      for (let j = i; j < end; j++) {\r\n        sum += rawData[j] * rawData[j];\r\n      }\r\n      const rms = Math.sqrt(sum / (end - i));\r\n      amplitudeData.push(rms);\r\n    }\r\n    \r\n    return {\r\n      pitchData: Array.from(pitchArray),\r\n      amplitudeData,\r\n      duration: audioBuffer.duration\r\n    };\r\n  }\r\n\r\n  async compareAudio(original: AudioFeatures, recorded: AudioFeatures): Promise<{\r\n    score: number;\r\n    durationMatch: number;\r\n    pitchMatch: number;\r\n    amplitudeMatch: number;\r\n  }> {\r\n    // Check if recording is just silence\r\n    const recordedAvgAmplitude = this.getAverageAmplitude(recorded.amplitudeData);\r\n    if (recordedAvgAmplitude < 0.01) {\r\n      return {\r\n        score: 0,\r\n        durationMatch: 0,\r\n        pitchMatch: 0,\r\n        amplitudeMatch: 0\r\n      };\r\n    }\r\n\r\n    // Duration score (20%)\r\n    const durationMatch = Math.max(0, 100 - \r\n      (Math.abs(original.duration - recorded.duration) / original.duration) * 100\r\n    );\r\n\r\n    // Pitch score (40%)\r\n    const pitchMatch = this.compareArrays(original.pitchData, recorded.pitchData);\r\n    \r\n    // Amplitude score (40%)\r\n    const amplitudeMatch = this.compareArrays(original.amplitudeData, recorded.amplitudeData);\r\n    \r\n    const score = Math.round(\r\n      durationMatch * 0.2 +\r\n      pitchMatch * 0.4 +\r\n      amplitudeMatch * 0.4\r\n    );\r\n\r\n    return {\r\n      score,\r\n      durationMatch,\r\n      pitchMatch,\r\n      amplitudeMatch\r\n    };\r\n  }\r\n\r\n  private getAverageAmplitude(arr: number[]): number {\r\n    if (arr.length === 0) return 0;\r\n    const sum = arr.reduce((a, b) => a + Math.abs(b), 0);\r\n    return sum / arr.length;\r\n  }\r\n\r\n  private compareArrays(arr1: number[], arr2: number[]): number {\r\n    const length = Math.min(arr1.length, arr2.length);\r\n    const normalizedArr1 = this.normalizeArray(arr1.slice(0, length));\r\n    const normalizedArr2 = this.normalizeArray(arr2.slice(0, length));\r\n    \r\n    let totalDiff = 0;\r\n    let significantPoints = 0;\r\n    \r\n    for (let i = 0; i < length; i++) {\r\n      // Only compare points where at least one signal has significant amplitude\r\n      if (normalizedArr1[i] > 0.1 || normalizedArr2[i] > 0.1) {\r\n        totalDiff += Math.abs(normalizedArr1[i] - normalizedArr2[i]);\r\n        significantPoints++;\r\n      }\r\n    }\r\n    \r\n    if (significantPoints === 0) return 0;\r\n    return Math.max(0, 100 - (totalDiff / significantPoints) * 100);\r\n  }\r\n\r\n  private normalizeArray(arr: number[]): number[] {\r\n    const max = Math.max(...arr);\r\n    if (max === 0) return arr; // Prevent division by zero\r\n    \r\n    return arr.map(value => value / max);\r\n  }\r\n\r\n  async audioBufferFromBlob(blob: Blob): Promise<AudioBuffer> {\r\n    const arrayBuffer = await blob.arrayBuffer();\r\n    return await this.context.decodeAudioData(arrayBuffer);\r\n  }\r\n}\r\n\r\nexport const audioAnalyzer = new AudioAnalyzer(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}