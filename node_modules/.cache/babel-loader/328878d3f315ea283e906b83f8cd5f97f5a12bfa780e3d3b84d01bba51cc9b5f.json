{"ast":null,"code":"export class AudioAnalyzer {\n  constructor() {\n    this.context = void 0;\n    this.context = new AudioContext();\n  }\n  async analyzePitch(audioBuffer) {\n    return new Promise(resolve => {\n      // Create analyzer nodes\n      const analyzer = this.context.createAnalyser();\n      analyzer.fftSize = 2048;\n\n      // Create buffer source\n      const source = this.context.createBufferSource();\n      source.buffer = audioBuffer;\n\n      // Connect nodes\n      source.connect(analyzer);\n      analyzer.connect(this.context.destination);\n\n      // Create data arrays\n      const pitchArray = new Float32Array(analyzer.frequencyBinCount);\n      const amplitudeArray = new Float32Array(analyzer.frequencyBinCount);\n\n      // Collect data when the audio plays\n      source.onended = () => {\n        analyzer.getFloatFrequencyData(pitchArray);\n        analyzer.getFloatTimeDomainData(amplitudeArray);\n        resolve({\n          pitchData: Array.from(pitchArray),\n          amplitudeData: Array.from(amplitudeArray),\n          duration: audioBuffer.duration\n        });\n      };\n\n      // Start the source\n      source.start(0);\n    });\n  }\n  async compareAudio(original, recorded) {\n    // Duration score\n    const durationMatch = Math.max(0, 100 - Math.abs(original.duration - recorded.duration) / original.duration * 100);\n\n    // Pitch score\n    const pitchMatch = this.compareArrays(original.pitchData, recorded.pitchData);\n\n    // Amplitude score\n    const amplitudeMatch = this.compareArrays(original.amplitudeData, recorded.amplitudeData);\n\n    // Weight the scores\n    const score = Math.round(durationMatch * 0.2 + pitchMatch * 0.5 + amplitudeMatch * 0.3);\n    return {\n      score,\n      durationMatch,\n      pitchMatch,\n      amplitudeMatch\n    };\n  }\n  compareArrays(arr1, arr2) {\n    // Ensure arrays are the same length\n    const length = Math.min(arr1.length, arr2.length);\n    const normalizedArr1 = this.normalizeArray(arr1.slice(0, length));\n    const normalizedArr2 = this.normalizeArray(arr2.slice(0, length));\n    let totalDiff = 0;\n    let validComparisons = 0;\n    for (let i = 0; i < length; i++) {\n      if (isFinite(normalizedArr1[i]) && isFinite(normalizedArr2[i])) {\n        totalDiff += Math.abs(normalizedArr1[i] - normalizedArr2[i]);\n        validComparisons++;\n      }\n    }\n    if (validComparisons === 0) return 0;\n\n    // Convert to similarity score (0-100)\n    const similarity = Math.max(0, 100 - totalDiff / validComparisons * 50);\n    return similarity;\n  }\n  normalizeArray(arr) {\n    const validNumbers = arr.filter(n => isFinite(n));\n    if (validNumbers.length === 0) return arr.map(() => 0);\n    const max = Math.max(...validNumbers);\n    const min = Math.min(...validNumbers);\n    const range = max - min || 1;\n    return arr.map(value => {\n      if (!isFinite(value)) return 0;\n      return (value - min) / range;\n    });\n  }\n  async audioBufferFromBlob(blob) {\n    const arrayBuffer = await blob.arrayBuffer();\n    return await this.context.decodeAudioData(arrayBuffer);\n  }\n}\nexport const audioAnalyzer = new AudioAnalyzer();","map":{"version":3,"names":["AudioAnalyzer","constructor","context","AudioContext","analyzePitch","audioBuffer","Promise","resolve","analyzer","createAnalyser","fftSize","source","createBufferSource","buffer","connect","destination","pitchArray","Float32Array","frequencyBinCount","amplitudeArray","onended","getFloatFrequencyData","getFloatTimeDomainData","pitchData","Array","from","amplitudeData","duration","start","compareAudio","original","recorded","durationMatch","Math","max","abs","pitchMatch","compareArrays","amplitudeMatch","score","round","arr1","arr2","length","min","normalizedArr1","normalizeArray","slice","normalizedArr2","totalDiff","validComparisons","i","isFinite","similarity","arr","validNumbers","filter","n","map","range","value","audioBufferFromBlob","blob","arrayBuffer","decodeAudioData","audioAnalyzer"],"sources":["C:/Users/ikesh/Desktop/voice-matcher/src/utils/audioAnalysis.ts"],"sourcesContent":["export interface AudioFeatures {\r\n  pitchData: number[];\r\n  amplitudeData: number[];\r\n  duration: number;\r\n}\r\n\r\nexport class AudioAnalyzer {\r\n  private context: AudioContext;\r\n  \r\n  constructor() {\r\n    this.context = new AudioContext();\r\n  }\r\n\r\n  async analyzePitch(audioBuffer: AudioBuffer): Promise<AudioFeatures> {\r\n    return new Promise((resolve) => {\r\n      // Create analyzer nodes\r\n      const analyzer = this.context.createAnalyser();\r\n      analyzer.fftSize = 2048;\r\n      \r\n      // Create buffer source\r\n      const source = this.context.createBufferSource();\r\n      source.buffer = audioBuffer;\r\n      \r\n      // Connect nodes\r\n      source.connect(analyzer);\r\n      analyzer.connect(this.context.destination);\r\n      \r\n      // Create data arrays\r\n      const pitchArray = new Float32Array(analyzer.frequencyBinCount);\r\n      const amplitudeArray = new Float32Array(analyzer.frequencyBinCount);\r\n      \r\n      // Collect data when the audio plays\r\n      source.onended = () => {\r\n        analyzer.getFloatFrequencyData(pitchArray);\r\n        analyzer.getFloatTimeDomainData(amplitudeArray);\r\n        \r\n        resolve({\r\n          pitchData: Array.from(pitchArray),\r\n          amplitudeData: Array.from(amplitudeArray),\r\n          duration: audioBuffer.duration\r\n        });\r\n      };\r\n      \r\n      // Start the source\r\n      source.start(0);\r\n    });\r\n  }\r\n\r\n  async compareAudio(original: AudioFeatures, recorded: AudioFeatures): Promise<{\r\n    score: number;\r\n    durationMatch: number;\r\n    pitchMatch: number;\r\n    amplitudeMatch: number;\r\n  }> {\r\n    // Duration score\r\n    const durationMatch = Math.max(0, 100 - \r\n      (Math.abs(original.duration - recorded.duration) / original.duration) * 100\r\n    );\r\n\r\n    // Pitch score\r\n    const pitchMatch = this.compareArrays(original.pitchData, recorded.pitchData);\r\n    \r\n    // Amplitude score\r\n    const amplitudeMatch = this.compareArrays(original.amplitudeData, recorded.amplitudeData);\r\n    \r\n    // Weight the scores\r\n    const score = Math.round(\r\n      durationMatch * 0.2 +\r\n      pitchMatch * 0.5 +\r\n      amplitudeMatch * 0.3\r\n    );\r\n\r\n    return {\r\n      score,\r\n      durationMatch,\r\n      pitchMatch,\r\n      amplitudeMatch\r\n    };\r\n  }\r\n\r\n  private compareArrays(arr1: number[], arr2: number[]): number {\r\n    // Ensure arrays are the same length\r\n    const length = Math.min(arr1.length, arr2.length);\r\n    const normalizedArr1 = this.normalizeArray(arr1.slice(0, length));\r\n    const normalizedArr2 = this.normalizeArray(arr2.slice(0, length));\r\n    \r\n    let totalDiff = 0;\r\n    let validComparisons = 0;\r\n    \r\n    for (let i = 0; i < length; i++) {\r\n      if (isFinite(normalizedArr1[i]) && isFinite(normalizedArr2[i])) {\r\n        totalDiff += Math.abs(normalizedArr1[i] - normalizedArr2[i]);\r\n        validComparisons++;\r\n      }\r\n    }\r\n    \r\n    if (validComparisons === 0) return 0;\r\n    \r\n    // Convert to similarity score (0-100)\r\n    const similarity = Math.max(0, 100 - (totalDiff / validComparisons) * 50);\r\n    return similarity;\r\n  }\r\n\r\n  private normalizeArray(arr: number[]): number[] {\r\n    const validNumbers = arr.filter(n => isFinite(n));\r\n    if (validNumbers.length === 0) return arr.map(() => 0);\r\n    \r\n    const max = Math.max(...validNumbers);\r\n    const min = Math.min(...validNumbers);\r\n    const range = max - min || 1;\r\n    \r\n    return arr.map(value => {\r\n      if (!isFinite(value)) return 0;\r\n      return (value - min) / range;\r\n    });\r\n  }\r\n\r\n  async audioBufferFromBlob(blob: Blob): Promise<AudioBuffer> {\r\n    const arrayBuffer = await blob.arrayBuffer();\r\n    return await this.context.decodeAudioData(arrayBuffer);\r\n  }\r\n}\r\n\r\nexport const audioAnalyzer = new AudioAnalyzer(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}