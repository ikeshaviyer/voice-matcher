{"ast":null,"code":"class AudioManager {\n  constructor() {\n    this.audioContext = null;\n    this.audioBuffers = new Map();\n    this.currentSource = null;\n    this.context = void 0;\n    this.initAudioContext();\n  }\n  initAudioContext() {\n    try {\n      this.audioContext = new AudioContext();\n    } catch (error) {\n      console.error('Failed to create AudioContext:', error);\n    }\n  }\n  async loadAudioClips(clips) {\n    for (const clip of clips) {\n      try {\n        const response = await fetch(clip.file);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await this.context.decodeAudioData(arrayBuffer);\n\n        // Set the actual duration in milliseconds\n        clip.duration = audioBuffer.duration * 1000;\n        this.audioBuffers.set(clip.id, audioBuffer);\n      } catch (error) {\n        console.error(`Failed to load audio clip ${clip.name}:`, error);\n      }\n    }\n  }\n  async loadAllClips(clips) {\n    await Promise.all(clips.map(clip => this.loadAudioClip(clip)));\n  }\n  play(clipId) {\n    return new Promise((resolve, reject) => {\n      if (!this.audioContext) {\n        reject(new Error('AudioContext not initialized'));\n        return;\n      }\n      const buffer = this.audioBuffers.get(clipId);\n      if (!buffer) {\n        reject(new Error(`Audio clip ${clipId} not loaded`));\n        return;\n      }\n\n      // Stop any currently playing audio\n      if (this.currentSource) {\n        this.currentSource.stop();\n      }\n\n      // Create and configure new source\n      this.currentSource = this.audioContext.createBufferSource();\n      this.currentSource.buffer = buffer;\n      this.currentSource.connect(this.audioContext.destination);\n\n      // Handle completion\n      this.currentSource.onended = () => {\n        this.currentSource = null;\n        resolve();\n      };\n\n      // Start playback\n      this.currentSource.start();\n    });\n  }\n  stop() {\n    if (this.currentSource) {\n      this.currentSource.stop();\n      this.currentSource = null;\n    }\n  }\n  getBuffer(clipId) {\n    return this.audioBuffers.get(clipId);\n  }\n}\n\n// Create a singleton instance\nexport const audioManager = new AudioManager();","map":{"version":3,"names":["AudioManager","constructor","audioContext","audioBuffers","Map","currentSource","context","initAudioContext","AudioContext","error","console","loadAudioClips","clips","clip","response","fetch","file","arrayBuffer","audioBuffer","decodeAudioData","duration","set","id","name","loadAllClips","Promise","all","map","loadAudioClip","play","clipId","resolve","reject","Error","buffer","get","stop","createBufferSource","connect","destination","onended","start","getBuffer","audioManager"],"sources":["C:/Users/ikesh/Desktop/voice-matcher/src/utils/audioUtils.ts"],"sourcesContent":["import { AudioClip } from '../types/audio';\r\n\r\nclass AudioManager {\r\n  private audioContext: AudioContext | null = null;\r\n  private audioBuffers: Map<string, AudioBuffer> = new Map();\r\n  private currentSource: AudioBufferSourceNode | null = null;\r\n  private context: AudioContext;\r\n\r\n  constructor() {\r\n    this.initAudioContext();\r\n  }\r\n\r\n  private initAudioContext() {\r\n    try {\r\n      this.audioContext = new AudioContext();\r\n    } catch (error) {\r\n      console.error('Failed to create AudioContext:', error);\r\n    }\r\n  }\r\n\r\n  async loadAudioClips(clips: AudioClip[]): Promise<void> {\r\n    for (const clip of clips) {\r\n      try {\r\n        const response = await fetch(clip.file);\r\n        const arrayBuffer = await response.arrayBuffer();\r\n        const audioBuffer = await this.context.decodeAudioData(arrayBuffer);\r\n        \r\n        // Set the actual duration in milliseconds\r\n        clip.duration = audioBuffer.duration * 1000;\r\n        \r\n        this.audioBuffers.set(clip.id, audioBuffer);\r\n      } catch (error) {\r\n        console.error(`Failed to load audio clip ${clip.name}:`, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  async loadAllClips(clips: AudioClip[]): Promise<void> {\r\n    await Promise.all(clips.map(clip => this.loadAudioClip(clip)));\r\n  }\r\n\r\n  play(clipId: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.audioContext) {\r\n        reject(new Error('AudioContext not initialized'));\r\n        return;\r\n      }\r\n\r\n      const buffer = this.audioBuffers.get(clipId);\r\n      if (!buffer) {\r\n        reject(new Error(`Audio clip ${clipId} not loaded`));\r\n        return;\r\n      }\r\n\r\n      // Stop any currently playing audio\r\n      if (this.currentSource) {\r\n        this.currentSource.stop();\r\n      }\r\n\r\n      // Create and configure new source\r\n      this.currentSource = this.audioContext.createBufferSource();\r\n      this.currentSource.buffer = buffer;\r\n      this.currentSource.connect(this.audioContext.destination);\r\n\r\n      // Handle completion\r\n      this.currentSource.onended = () => {\r\n        this.currentSource = null;\r\n        resolve();\r\n      };\r\n\r\n      // Start playback\r\n      this.currentSource.start();\r\n    });\r\n  }\r\n\r\n  stop() {\r\n    if (this.currentSource) {\r\n      this.currentSource.stop();\r\n      this.currentSource = null;\r\n    }\r\n  }\r\n\r\n  getBuffer(clipId: string): AudioBuffer | undefined {\r\n    return this.audioBuffers.get(clipId);\r\n  }\r\n}\r\n\r\n// Create a singleton instance\r\nexport const audioManager = new AudioManager(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}