{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef } from 'react';\nexport const useVoiceRecorder = deviceId => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [error, setError] = useState(null);\n  const mediaRecorder = useRef(null);\n  const chunks = useRef([]);\n  const startRecording = async () => {\n    try {\n      chunks.current = [];\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          deviceId: {\n            exact: deviceId\n          },\n          echoCancellation: false,\n          noiseSuppression: false,\n          autoGainControl: false\n        }\n      });\n      mediaRecorder.current = new MediaRecorder(stream, {\n        mimeType: 'audio/webm'\n      });\n      mediaRecorder.current.ondataavailable = e => {\n        if (e.data.size > 0) {\n          chunks.current.push(e.data);\n        }\n      };\n      mediaRecorder.current.start();\n      setIsRecording(true);\n      setError(null);\n    } catch (err) {\n      setError('Failed to start recording');\n      console.error('Recording error:', err);\n    }\n  };\n  const stopRecording = async () => {\n    return new Promise((resolve, reject) => {\n      if (!mediaRecorder.current || mediaRecorder.current.state === 'inactive') {\n        reject(new Error('No active recording'));\n        return;\n      }\n      mediaRecorder.current.onstop = () => {\n        var _mediaRecorder$curren;\n        const blob = new Blob(chunks.current, {\n          type: 'audio/webm'\n        });\n        chunks.current = [];\n        setIsRecording(false);\n        resolve(blob);\n\n        // Stop all tracks\n        (_mediaRecorder$curren = mediaRecorder.current) === null || _mediaRecorder$curren === void 0 ? void 0 : _mediaRecorder$curren.stream.getTracks().forEach(track => track.stop());\n      };\n      mediaRecorder.current.stop();\n    });\n  };\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    error\n  };\n};\n_s(useVoiceRecorder, \"AanfGgg5EGTXt6PlUCLcA2JwxmY=\");","map":{"version":3,"names":["useState","useRef","useVoiceRecorder","deviceId","_s","isRecording","setIsRecording","error","setError","mediaRecorder","chunks","startRecording","current","stream","navigator","mediaDevices","getUserMedia","audio","exact","echoCancellation","noiseSuppression","autoGainControl","MediaRecorder","mimeType","ondataavailable","e","data","size","push","start","err","console","stopRecording","Promise","resolve","reject","state","Error","onstop","_mediaRecorder$curren","blob","Blob","type","getTracks","forEach","track","stop"],"sources":["C:/Users/ikesh/Desktop/voice-matcher/src/hooks/useVoiceRecorder.ts"],"sourcesContent":["import { useState, useRef } from 'react';\r\n\r\ninterface VoiceRecorderHook {\r\n  startRecording: () => Promise<void>;\r\n  stopRecording: () => Promise<Blob>;\r\n  isRecording: boolean;\r\n  error: string | null;\r\n}\r\n\r\nexport const useVoiceRecorder = (deviceId: string): VoiceRecorderHook => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const mediaRecorder = useRef<MediaRecorder | null>(null);\r\n  const chunks = useRef<Blob[]>([]);\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      chunks.current = [];\r\n      const stream = await navigator.mediaDevices.getUserMedia({\r\n        audio: {\r\n          deviceId: { exact: deviceId },\r\n          echoCancellation: false,\r\n          noiseSuppression: false,\r\n          autoGainControl: false\r\n        }\r\n      });\r\n\r\n      mediaRecorder.current = new MediaRecorder(stream, {\r\n        mimeType: 'audio/webm'\r\n      });\r\n\r\n      mediaRecorder.current.ondataavailable = (e) => {\r\n        if (e.data.size > 0) {\r\n          chunks.current.push(e.data);\r\n        }\r\n      };\r\n\r\n      mediaRecorder.current.start();\r\n      setIsRecording(true);\r\n      setError(null);\r\n    } catch (err) {\r\n      setError('Failed to start recording');\r\n      console.error('Recording error:', err);\r\n    }\r\n  };\r\n\r\n  const stopRecording = async (): Promise<Blob> => {\r\n    return new Promise((resolve, reject) => {\r\n      if (!mediaRecorder.current || mediaRecorder.current.state === 'inactive') {\r\n        reject(new Error('No active recording'));\r\n        return;\r\n      }\r\n\r\n      mediaRecorder.current.onstop = () => {\r\n        const blob = new Blob(chunks.current, { type: 'audio/webm' });\r\n        chunks.current = [];\r\n        setIsRecording(false);\r\n        resolve(blob);\r\n\r\n        // Stop all tracks\r\n        mediaRecorder.current?.stream.getTracks().forEach(track => track.stop());\r\n      };\r\n\r\n      mediaRecorder.current.stop();\r\n    });\r\n  };\r\n\r\n  return {\r\n    startRecording,\r\n    stopRecording,\r\n    isRecording,\r\n    error\r\n  };\r\n}; "],"mappings":";AAAA,SAASA,QAAQ,EAAEC,MAAM,QAAQ,OAAO;AASxC,OAAO,MAAMC,gBAAgB,GAAIC,QAAgB,IAAwB;EAAAC,EAAA;EACvE,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGN,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACO,KAAK,EAAEC,QAAQ,CAAC,GAAGR,QAAQ,CAAgB,IAAI,CAAC;EACvD,MAAMS,aAAa,GAAGR,MAAM,CAAuB,IAAI,CAAC;EACxD,MAAMS,MAAM,GAAGT,MAAM,CAAS,EAAE,CAAC;EAEjC,MAAMU,cAAc,GAAG,MAAAA,CAAA,KAAY;IACjC,IAAI;MACFD,MAAM,CAACE,OAAO,GAAG,EAAE;MACnB,MAAMC,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QACvDC,KAAK,EAAE;UACLd,QAAQ,EAAE;YAAEe,KAAK,EAAEf;UAAS,CAAC;UAC7BgB,gBAAgB,EAAE,KAAK;UACvBC,gBAAgB,EAAE,KAAK;UACvBC,eAAe,EAAE;QACnB;MACF,CAAC,CAAC;MAEFZ,aAAa,CAACG,OAAO,GAAG,IAAIU,aAAa,CAACT,MAAM,EAAE;QAChDU,QAAQ,EAAE;MACZ,CAAC,CAAC;MAEFd,aAAa,CAACG,OAAO,CAACY,eAAe,GAAIC,CAAC,IAAK;QAC7C,IAAIA,CAAC,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACnBjB,MAAM,CAACE,OAAO,CAACgB,IAAI,CAACH,CAAC,CAACC,IAAI,CAAC;QAC7B;MACF,CAAC;MAEDjB,aAAa,CAACG,OAAO,CAACiB,KAAK,CAAC,CAAC;MAC7BvB,cAAc,CAAC,IAAI,CAAC;MACpBE,QAAQ,CAAC,IAAI,CAAC;IAChB,CAAC,CAAC,OAAOsB,GAAG,EAAE;MACZtB,QAAQ,CAAC,2BAA2B,CAAC;MACrCuB,OAAO,CAACxB,KAAK,CAAC,kBAAkB,EAAEuB,GAAG,CAAC;IACxC;EACF,CAAC;EAED,MAAME,aAAa,GAAG,MAAAA,CAAA,KAA2B;IAC/C,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI,CAAC1B,aAAa,CAACG,OAAO,IAAIH,aAAa,CAACG,OAAO,CAACwB,KAAK,KAAK,UAAU,EAAE;QACxED,MAAM,CAAC,IAAIE,KAAK,CAAC,qBAAqB,CAAC,CAAC;QACxC;MACF;MAEA5B,aAAa,CAACG,OAAO,CAAC0B,MAAM,GAAG,MAAM;QAAA,IAAAC,qBAAA;QACnC,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAAC/B,MAAM,CAACE,OAAO,EAAE;UAAE8B,IAAI,EAAE;QAAa,CAAC,CAAC;QAC7DhC,MAAM,CAACE,OAAO,GAAG,EAAE;QACnBN,cAAc,CAAC,KAAK,CAAC;QACrB4B,OAAO,CAACM,IAAI,CAAC;;QAEb;QACA,CAAAD,qBAAA,GAAA9B,aAAa,CAACG,OAAO,cAAA2B,qBAAA,uBAArBA,qBAAA,CAAuB1B,MAAM,CAAC8B,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;MAC1E,CAAC;MAEDrC,aAAa,CAACG,OAAO,CAACkC,IAAI,CAAC,CAAC;IAC9B,CAAC,CAAC;EACJ,CAAC;EAED,OAAO;IACLnC,cAAc;IACdqB,aAAa;IACb3B,WAAW;IACXE;EACF,CAAC;AACH,CAAC;AAACH,EAAA,CAhEWF,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}