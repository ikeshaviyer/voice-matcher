{"ast":null,"code":"export class AudioAnalyzer {\n  constructor() {\n    this.context = void 0;\n    this.context = new AudioContext();\n  }\n  async analyzePitch(audioBuffer) {\n    const analyzer = this.context.createAnalyser();\n    analyzer.fftSize = 2048;\n    const source = this.context.createBufferSource();\n    source.buffer = audioBuffer;\n    source.connect(analyzer);\n\n    // Create data array for amplitude\n    const amplitudeArray = new Float32Array(analyzer.frequencyBinCount);\n\n    // Get amplitude data\n    analyzer.getFloatTimeDomainData(amplitudeArray);\n    return {\n      amplitudeData: Array.from(amplitudeArray),\n      duration: audioBuffer.duration\n    };\n  }\n  async compareAudio(original, recorded) {\n    // Duration score (30%)\n    const durationMatch = Math.max(0, 100 - Math.abs(original.duration - recorded.duration) / original.duration * 100);\n\n    // Amplitude score (70%)\n    const amplitudeMatch = this.compareArrays(original.amplitudeData, recorded.amplitudeData);\n\n    // Calculate final score\n    const score = Math.round(durationMatch * 0.3 + amplitudeMatch * 0.7);\n    return {\n      score,\n      durationMatch,\n      amplitudeMatch\n    };\n  }\n  compareArrays(arr1, arr2) {\n    const length = Math.min(arr1.length, arr2.length);\n    const normalizedArr1 = this.normalizeArray(arr1.slice(0, length));\n    const normalizedArr2 = this.normalizeArray(arr2.slice(0, length));\n    let totalDiff = 0;\n    for (let i = 0; i < length; i++) {\n      totalDiff += Math.abs(normalizedArr1[i] - normalizedArr2[i]);\n    }\n    return Math.max(0, 100 - totalDiff / length * 100);\n  }\n  normalizeArray(arr) {\n    const max = Math.max(...arr);\n    const min = Math.min(...arr);\n    const range = max - min || 1;\n    return arr.map(value => (value - min) / range);\n  }\n  async audioBufferFromBlob(blob) {\n    const arrayBuffer = await blob.arrayBuffer();\n    return await this.context.decodeAudioData(arrayBuffer);\n  }\n}\nexport const audioAnalyzer = new AudioAnalyzer();","map":{"version":3,"names":["AudioAnalyzer","constructor","context","AudioContext","analyzePitch","audioBuffer","analyzer","createAnalyser","fftSize","source","createBufferSource","buffer","connect","amplitudeArray","Float32Array","frequencyBinCount","getFloatTimeDomainData","amplitudeData","Array","from","duration","compareAudio","original","recorded","durationMatch","Math","max","abs","amplitudeMatch","compareArrays","score","round","arr1","arr2","length","min","normalizedArr1","normalizeArray","slice","normalizedArr2","totalDiff","i","arr","range","map","value","audioBufferFromBlob","blob","arrayBuffer","decodeAudioData","audioAnalyzer"],"sources":["C:/Users/ikesh/Desktop/voice-matcher/src/utils/audioAnalysis.ts"],"sourcesContent":["export interface AudioFeatures {\r\n  amplitudeData: number[];\r\n  duration: number;\r\n}\r\n\r\nexport class AudioAnalyzer {\r\n  private context: AudioContext;\r\n  \r\n  constructor() {\r\n    this.context = new AudioContext();\r\n  }\r\n\r\n  async analyzePitch(audioBuffer: AudioBuffer): Promise<AudioFeatures> {\r\n    const analyzer = this.context.createAnalyser();\r\n    analyzer.fftSize = 2048;\r\n    \r\n    const source = this.context.createBufferSource();\r\n    source.buffer = audioBuffer;\r\n    source.connect(analyzer);\r\n    \r\n    // Create data array for amplitude\r\n    const amplitudeArray = new Float32Array(analyzer.frequencyBinCount);\r\n    \r\n    // Get amplitude data\r\n    analyzer.getFloatTimeDomainData(amplitudeArray);\r\n    \r\n    return {\r\n      amplitudeData: Array.from(amplitudeArray),\r\n      duration: audioBuffer.duration\r\n    };\r\n  }\r\n\r\n  async compareAudio(original: AudioFeatures, recorded: AudioFeatures): Promise<{\r\n    score: number;\r\n    durationMatch: number;\r\n    amplitudeMatch: number;\r\n  }> {\r\n    // Duration score (30%)\r\n    const durationMatch = Math.max(0, 100 - \r\n      (Math.abs(original.duration - recorded.duration) / original.duration) * 100\r\n    );\r\n\r\n    // Amplitude score (70%)\r\n    const amplitudeMatch = this.compareArrays(original.amplitudeData, recorded.amplitudeData);\r\n    \r\n    // Calculate final score\r\n    const score = Math.round(\r\n      durationMatch * 0.3 +\r\n      amplitudeMatch * 0.7\r\n    );\r\n\r\n    return {\r\n      score,\r\n      durationMatch,\r\n      amplitudeMatch\r\n    };\r\n  }\r\n\r\n  private compareArrays(arr1: number[], arr2: number[]): number {\r\n    const length = Math.min(arr1.length, arr2.length);\r\n    const normalizedArr1 = this.normalizeArray(arr1.slice(0, length));\r\n    const normalizedArr2 = this.normalizeArray(arr2.slice(0, length));\r\n    \r\n    let totalDiff = 0;\r\n    for (let i = 0; i < length; i++) {\r\n      totalDiff += Math.abs(normalizedArr1[i] - normalizedArr2[i]);\r\n    }\r\n    \r\n    return Math.max(0, 100 - (totalDiff / length) * 100);\r\n  }\r\n\r\n  private normalizeArray(arr: number[]): number[] {\r\n    const max = Math.max(...arr);\r\n    const min = Math.min(...arr);\r\n    const range = max - min || 1;\r\n    \r\n    return arr.map(value => (value - min) / range);\r\n  }\r\n\r\n  async audioBufferFromBlob(blob: Blob): Promise<AudioBuffer> {\r\n    const arrayBuffer = await blob.arrayBuffer();\r\n    return await this.context.decodeAudioData(arrayBuffer);\r\n  }\r\n}\r\n\r\nexport const audioAnalyzer = new AudioAnalyzer(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}